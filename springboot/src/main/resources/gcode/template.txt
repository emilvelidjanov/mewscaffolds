; >>>>>>>>>>>>>>>>>>>> CONFIGURATION <<<<<<<<<<<<<<<<<<<<
T=770
P=40

; Maximum width of the collector in X direction
1 XMAX! = 230
; Minimum width of the collector in X direction
1 XMIN! = 70
; Maximum height of the collector in Y direction
1 YMAX! = 194
; Minimum height of the collector in Y direction
1 YMIN! = 40
; Distance of print head from the collector in Z direction
1 ZDIST! = 4
; Speed / feedrate of the print head
1 SPEED! = 350 

LP moveAbsoluteZ(ZDIST!)
LP moveAbsolute(XMIN!, YMAX!, SPEED!)
LP initCoordinateSystem()



; >>>>>>>>>>>>>>>>>>>> VARIABLES <<<<<<<<<<<<<<<<<<<<
; Margin to keep some extra space from the slide edges
1 SLIDE_MARGIN! = 2
; The height of a single slide
1 SLIDE_HEIGHT! = 26
; The width of a single slide
1 SLIDE_WIDTH! = 76

; Position of the scaffold in X
1 X_SCAFFOLD_POSITION! = 0
; Position of the scaffold in Y
1 Y_SCAFFOLD_POSITION! = 0
; The length of a fiber
1 FIBER_LENGTH! = 10
; The distance between 2 parallel fibers
1 FIBER_DISTANCE! = 0.2
; Number of fibers
1 FIBER_NUMBER% = 50
; Mathematical angle of the fibers (relative to x-axis)
1 FIBER_ANGLE! = 0
; Width of the layer (equals the length of its fiber)
1 LAYER_WIDTH! = FIBER_LENGTH!
; Height of the layer
1 LAYER_HEIGHT! = (FIBER_NUMBER% * FIBER_DISTANCE!) - FIBER_DISTANCE!
; Wait time into the circular motion at the end of a fiber (in seconds)
1 WAIT_IN! = 0.2
; Wait time out of the circular motion at the end of a fiber (in seconds)
1 WAIT_OUT! = 0.06



; >>>>>>>>>>>>>>>>>>>> STABILIZATION <<<<<<<<<<<<<<<<<<<<
; Height of the stabilization area
1 STAB_HEIGHT! = 15
; Width of the stabilization area
1 STAB_WIDTH! = 15
; Move in place so the stabilization is centered vertically on the slide
LP moveRelative(SLIDE_MARGIN!, SLIDE_HEIGHT! / 2, SPEED!)
; Stabilize for about 10 minutes
LP stabilize(1, 1, STAB_WIDTH!, STAB_HEIGHT!, 1, SPEED!)



; >>>>>>>>>>>>>>>>>>>> MAIN PROGRAM <<<<<<<<<<<<<<<<<<<<
; Move to the slide above the stabilization slide
LP moveAbsolute(0, -SLIDE_HEIGHT! / 2, SPEED!)
LP initCoordinateSystem()

; Radius of the navigation from previous layer to next layer
1 ORBIT_RADIUS! = 10
; Recalculate scaffold positions
1 X_SCAFFOLD_POSITION! = SLIDE_MARGIN! + ORBIT_RADIUS! + LAYER_WIDTH! / 2
1 Y_SCAFFOLD_POSITION! = -SLIDE_HEIGHT! / 2

; Print
; Layer at 0째 angle
LP navigateToNextLayer(X_SCAFFOLD_POSITION!, Y_SCAFFOLD_POSITION!, ORBIT_RADIUS!, FIBER_ANGLE!, FIBER_ANGLE!, LAYER_WIDTH!, LAYER_HEIGHT!)
LP drawLayer(FIBER_NUMBER%, FIBER_LENGTH!, FIBER_DISTANCE!, FIBER_ANGLE!, WAIT_IN!, WAIT_OUT!, SPEED!)

; Layer at 45째 angle
LP navigateToNextLayer(X_SCAFFOLD_POSITION!, Y_SCAFFOLD_POSITION!, ORBIT_RADIUS!, FIBER_ANGLE!, FIBER_ANGLE! + 45, LAYER_WIDTH!, LAYER_HEIGHT!)
LP drawLayer(FIBER_NUMBER%, FIBER_LENGTH!, FIBER_DISTANCE!, FIBER_ANGLE! + 45, WAIT_IN!, WAIT_OUT!, SPEED!)

; Layer at 90째 angle
LP navigateToNextLayer(X_SCAFFOLD_POSITION!, Y_SCAFFOLD_POSITION!, ORBIT_RADIUS!, FIBER_ANGLE! + 45, FIBER_ANGLE! + 90, LAYER_WIDTH!, LAYER_HEIGHT!)
LP drawLayer(FIBER_NUMBER%, FIBER_LENGTH!, FIBER_DISTANCE!, FIBER_ANGLE! + 90, WAIT_IN!, WAIT_OUT!, SPEED!)

; Layer at 135째 angle
LP navigateToNextLayer(X_SCAFFOLD_POSITION!, Y_SCAFFOLD_POSITION!, ORBIT_RADIUS!, FIBER_ANGLE! + 90, FIBER_ANGLE! + 135, LAYER_WIDTH!, LAYER_HEIGHT!)
LP drawLayer(FIBER_NUMBER%, FIBER_LENGTH!, FIBER_DISTANCE!, FIBER_ANGLE! + 135, WAIT_IN!, WAIT_OUT!, SPEED!)



; >>>>>>>>>>>>>>>>>>>> SUBROUTINES <<<<<<<<<<<<<<<<<<<<
; Moves in absolute coordinates.
; P1 - X coordinate
; P2 - Y coordinate
; P3 - Feedrate
LPS moveAbsolute
1	X_COORD! = P1
1	Y_COORD! = P2
1	SPEED! = P3
	G90 G01 X[X_COORD!] Y[Y_COORD!] F[SPEED!]
PEND

; Moves relative to the current position.
; P1 - X offset
; P2 - Y offset
; P3 - Feedrate
LPS moveRelative
1	X_COORD! = P1
1	Y_COORD! = P2
1	SPEED! = P3
	G91 G01 X[X_COORD!] Y[Y_COORD!] F[SPEED!]
PEND

; Moves relative to current position.
; P1 - Length of the movement
; P2 - Mathematical angle of the movement (X-axis = 0)
; P3 - Feedrate
LPS movePolarRelativeX
1	LENGTH! = P1
1	ANGLE! = P2
1	SPEED! = P3
	POP()
	G91 G01(POL) X[LENGTH!] A[ANGLE!] F[SPEED!]
PEND

; Moves in absolute coordinates in Z-Direction with a set speed of 100.
; P1 - Distance to move in Z direction
LPS moveAbsoluteZ
1	ZDIST! = P1
	G90 G01 Z[ZDIST!] F100
PEND

; Sets the origin of the coordinate system to the current position.
LPS initCoordinateSystem
	G92 X[0] Y[0] Z[0]
PEND

; Pauses movement.
; P1 - Time to pause in seconds
LPS waitForSeconds
1	SECONDS! = P1
	G04 F[SECONDS!]
PEND

; Moves in a clockwise circle in absolute coordinates.
; P1 - Target point X
; P2 - Target point Y
; P3 - Circle center point X
; P4 - Circle center point Y
; P5 - Wait time into the circle motion in seconds
; P6 - Wait time out of the circle motion in seconds
; P7 - Feedrate
LPS moveClockwiseAbsolute
1	X_TARGET! = P1
1	Y_TARGET! = P2
1	X_CENTER_OFFSET! = P3
1	Y_CENTER_OFFSET! = P4
1	SPEED! = P5
	G90 G02 X[X_TARGET!] Y[Y_TARGET!] I[X_CENTER_OFFSET!] J[Y_CENTER_OFFSET!] F[SPEED!]
PEND

; Moves in a clockwise circle relative to current position.
; P1 - Target point X offset
; P2 - Target point Y offset
; P3 - Circle center point X offset
; P4 - Circle center point Y offset
; P5 - Wait time into the circle motion in seconds
; P6 - Wait time out of the circle motion in seconds
; P7 - Feedrate
LPS moveClockwiseRelative
1	X_TARGET_OFFSET! = P1
1	Y_TARGET_OFFSET! = P2
1	X_CENTER_OFFSET! = P3
1	Y_CENTER_OFFSET! = P4
1	WAIT_IN! = P5
1	WAIT_OUT! = P6
1	SPEED! = P7
	LP waitForSeconds(WAIT_IN!)
	G91 G02 X[X_TARGET_OFFSET!] Y[Y_TARGET_OFFSET!] I[X_CENTER_OFFSET!] J[Y_CENTER_OFFSET!] F[SPEED!]
	LP waitForSeconds(WAIT_OUT!)
PEND

; Moves in a counter clockwise circle relative to current position.
; P1 - Target point X offset
; P2 - Target point Y offset
; P3 - Circle center point X offset
; P4 - Circle center point Y offset
; P5 - Wait time into the circle motion in seconds
; P6 - Wait time out of the circle motion in seconds
; P7 - Feedrate
LPS moveCounterClockwiseRelative
1	X_TARGET_OFFSET! = P1
1	Y_TARGET_OFFSET! = P2
1	X_CENTER_OFFSET! = P3
1	Y_CENTER_OFFSET! = P4
1	WAIT_IN! = P5
1	WAIT_OUT! = P6
1	SPEED! = P7
	LP waitForSeconds(WAIT_IN!)
	G91 G03 X[X_TARGET_OFFSET!] Y[Y_TARGET_OFFSET!] I[X_CENTER_OFFSET!] J[Y_CENTER_OFFSET!] F[SPEED!]
	LP waitForSeconds(WAIT_OUT!)
PEND

; Moves in a clockwise circle relative to current position.
; The radius of the circle is equal to 1.
; P1 - Distance to target point
; P2 - Angle to target point
; P3 - Wait time into the circle motion in seconds
; P4 - Wait time out of the circle motion in seconds
; P5 - Feedrate
LPS moveClockwisePolarX
1	TARGET_DISTANCE! = P1
1	TARGET_ANGLE! = P2
1	WAIT_IN! = P3
1	WAIT_OUT! = P4
1	SPEED! = P5
1	RADIUS! = 1
	LP waitForSeconds(WAIT_IN!)
	POP(ACTPOS)
	G91 G02(POL) X[TARGET_DISTANCE!] A[TARGET_ANGLE!] R[-RADIUS!] F[SPEED!]
	LP waitForSeconds(WAIT_OUT!)
PEND

; Moves in a counter clockwise circle relative to current position.
; The radius of the circle is equal to 1.
; P1 - Distance to target point
; P2 - Angle to target point
; P3 - Wait time into the circle motion in seconds
; P4 - Wait time out of the circle motion in seconds
; P5 - Feedrate
LPS moveCounterClockwisePolarX
1	TARGET_DISTANCE! = P1
1	TARGET_ANGLE! = P2
1	WAIT_IN! = P3
1	WAIT_OUT! = P4
1	SPEED! = P5
1	RADIUS! = 1
	LP waitForSeconds(WAIT_IN!)
	POP(ACTPOS)
	G91 G03(POL) X[TARGET_DISTANCE!] A[TARGET_ANGLE!] R[-RADIUS!] F[SPEED!]
	LP waitForSeconds(WAIT_OUT!)
PEND

; Line test.
; P1 - Length of each line
; P2 - Distance between the lines
; P3 - Number of lines to draw
; P4 - Feedrate
LPS lineTest
1	LINE_LENGTH! = P1
1 	LINE_DISTANCE! = P2
1 	LINE_NUMBER% = INT(ROUND(P3 / 2))
1 	SPEED! = P4
1 	LOOP_SIZE! = LINE_DISTANCE! / 2
1 	WAIT_IN! = 0.2
1 	WAIT_OUT! = 0.2
1 	FOR I%=1 TO LINE_NUMBER%
1		ADDITIONAL_DISTANCE! = 0
1		EVEN_CHECK% = INT(I% / 2) * 2
1		IF EVEN_CHECK% = I% THEN
1			ADDITIONAL_DISTANCE! = LINE_DISTANCE!
1		ENDIF		
		LP movePolarRelativeX(LINE_LENGTH!, 90, SPEED!)
		LP moveClockwisePolarX(LINE_DISTANCE! + ADDITIONAL_DISTANCE!, 0, WAIT_IN!, WAIT_OUT!, SPEED!)
		LP movePolarRelativeX(LINE_LENGTH!, -90, SPEED!)
		LP moveCounterClockwisePolarX(LINE_DISTANCE!, 0, WAIT_IN!, WAIT_OUT!, SPEED!)
1 	NEXT I%
PEND

; Draws a single fiber.
; P1 - Length of the fiber
; P2 - Mathematical angle of the fiber (relative to X-axis)
; P3 - Distance to the next fiber
; P4 - Whether to do a clockwise (1) or counter clockwise (0) circle at the end of the fiber
; P5 - Wait time into the circle motion in seconds
; P6 - Wait time out of the circle motion in seconds
; P7 - Feedrate
LPS drawFiber
1	FIBER_LENGTH! = P1
1	FIBER_ANGLE! = P2
1	FIBER_DISTANCE! = P3
1	CLOCKWISE_TURN% = INT(P4)
1	WAIT_IN! = P5
1	WAIT_OUT! = P6
1	SPEED! = P7
	LP movePolarRelativeX(FIBER_LENGTH!, FIBER_ANGLE!, SPEED!)
1	IF CLOCKWISE_TURN% = 1 THEN
1		CIRCLE_ANGLE! = FIBER_ANGLE! - 90
		LP moveClockwisePolarX(FIBER_DISTANCE!, CIRCLE_ANGLE!, WAIT_IN!, WAIT_OUT!, SPEED!)
1	ELSE
1		CIRCLE_ANGLE! = FIBER_ANGLE! + 90
		LP moveCounterClockwisePolarX(FIBER_DISTANCE!, CIRCLE_ANGLE!, WAIT_IN!, WAIT_OUT!, SPEED!)
1	ENDIF
PEND

; Draws a single layer.
; First fiber circle always goes counter clockwise and fibers are always parallel to each other.
; P1 - Number of fibers
; P2 - Length of every fiber
; P3 - Distance between every fiber
; P4 - Mathematical angle of every fiber (relative to X-axis)
; P5 - Wait time into the circle motion in seconds for every fiber
; P6 - Wait time out of the circle motion in seconds for every fiber
; P7 - Feedrate for every fiber
LPS drawLayer
1	FIBER_NUMBER% = INT(P1)
1	FIBER_LENGTH! = P2
1	FIBER_DISTANCE! = P3
1	FIBER_ANGLE! = P4
1	WAIT_IN! = P5
1	WAIT_OUT! = P6
1	SPEED! = P7
1 	FOR I%=1 TO FIBER_NUMBER%
1		CLOCKWISE% = 0
1		PARALLEL_ANGLE! = 0
1		EVEN_CHECK% = INT(I% / 2) * 2
1		IF EVEN_CHECK% = I% THEN
1			CLOCKWISE% = 1
1			PARALLEL_ANGLE! = 180
1		ENDIF
		LP drawFiber(FIBER_LENGTH!, PARALLEL_ANGLE! + FIBER_ANGLE!, FIBER_DISTANCE!, CLOCKWISE%, WAIT_IN!, WAIT_OUT!, SPEED!)
1 	NEXT I%
PEND

; Orbits around the scaffold to move into position for the next layer.
; P1 - X position of the scaffolds center
; P2 - Y position of the scaffolds center
; P3 - Radius of the navigation-orbit around the layer
; P4 - Angle of the previous layer (should equal P5 if it's the first layer)
; P5 - Angle of the next layer
; P6 - Width of the next layer
; P7 - Height of the next layer
LPS navigateToNextLayer
1	X_CENTER! = P1
1	Y_CENTER! = P2
1	ORBIT_RADIUS! = P3
1	PREVIOUS_LAYER_ANGLE! = P4
1	NEXT_LAYER_ANGLE! = P5
1	LAYER_WIDTH! = P6
1	LAYER_HEIGHT! = P7
1	INTO_ORBIT_ANGLE! = PREVIOUS_LAYER_ANGLE! + 90
1	ORBIT_END_POINT_ANGLE! = NEXT_LAYER_ANGLE! + 180
1	CORR_ANGLE! = NEXT_LAYER_ANGLE! + 270
1	CORR_HEIGHT_LENGTH! = LAYER_HEIGHT! / 2
1	CORR_WIDTH_LENGTH! = ORBIT_RADIUS! - (LAYER_WIDTH! / 2)
1	X_START_POINT! = X_CENTER! + (ORBIT_RADIUS! * COS(INTO_ORBIT_ANGLE!))
1	Y_START_POINT! = Y_CENTER! + (ORBIT_RADIUS! * SIN(INTO_ORBIT_ANGLE!))
1	X_END_POINT! = X_CENTER! + (ORBIT_RADIUS! * COS(ORBIT_END_POINT_ANGLE!))
1	Y_END_POINT! = Y_CENTER! + (ORBIT_RADIUS! * SIN(ORBIT_END_POINT_ANGLE!))
1	DEF_SPEED! = 350
1	DEF_WAIT! = 0.2
LP moveAbsolute(X_START_POINT!, Y_START_POINT!, DEF_SPEED!)
LP moveClockwiseAbsolute(X_END_POINT!, Y_END_POINT!, X_CENTER! - X_START_POINT!, Y_CENTER! - Y_START_POINT!, DEF_SPEED!)
LP waitForSeconds(DEF_WAIT!)
LP movePolarRelativeX(CORR_HEIGHT_LENGTH!, CORR_ANGLE!, DEF_SPEED!)
LP movePolarRelativeX(CORR_WIDTH_LENGTH!, NEXT_LAYER_ANGLE!, DEF_SPEED!)
PEND

LPS stabilize
;Rectangular construct with chainmail pattern for constant speed
;Parameters: P1-hight(layers), P2 - circle radius, P3 - Size in X-direction
;P4 - size in Y-direction, P5 - circle spacing, P6 - linear speed
;!!!!! diagonal entering movement cancelled

1 H=P1
1 CRAD=P2
1 XSIZE=P3
1 YSIZE=P4
1 CSPC=P5
1 FEEDL=P6

1 NCX%=INT(XSIZE/CSPC)
1 NDCY%=INT(YSIZE/(2*CSPC))

G91	
G1 	X0	Y[-CSPC*(NDCY%-1)+CRAD]		F[FEEDL]
G3 	X[CRAD]	Y[-CRAD]	R[CRAD]	F[FEEDL]

1 FOR I%=1 TO H
1	FOR J%=1 TO NDCY%
1		FOR K%=1 TO (NCX%-1)
			G2 X0		Y0	I0 J[-CRAD]	F[FEEDL]
			G1 X[CSPC]	Y0	F[FEEDL]	
1		NEXT K%	
		G2 X0		Y0		I0 J[-CRAD]	F[FEEDL]
		G2 X[CRAD]	Y[-CRAD]	R[CRAD]	F[FEEDL]
		G1 X0		Y[-CSPC*(1+2*(J%-1))]			F[FEEDL]
		G2 X[-CRAD]	Y[-CRAD]	R[CRAD]	F[FEEDL]
1		FOR K%=1 TO (NCX%-1)
			G2 X0		Y0	I0 J[CRAD]	F[FEEDL]
			G1 X[-CSPC]	Y0	F[FEEDL]	
1		NEXT K%
		G2 X0		Y0	I0 J[CRAD]	F[FEEDL]
		G2 X[-CRAD]	Y[CRAD]	R[CRAD]	F[FEEDL]
1		IF J%<NDCY%	THEN
			G1	X0	Y[CSPC*2*J%]
			G2 X[CRAD]	Y[CRAD]	R[CRAD]	F[FEEDL]
1		ELSE
			G1	X0	Y[CSPC*J%]
1			IF I%<H THEN
				G2	X[CRAD]	Y[CRAD]	R[CRAD]	F[FEEDL]
1			ELSE
				G1 X0	Y[CSPC*(J%-1)]		F[FEEDL]
				G3	X[-CRAD]	Y[CRAD]	R[CRAD]	F[FEEDL]
1			ENDIF	
1		ENDIF
1 	NEXT J%
1 NEXT I%
PEND

